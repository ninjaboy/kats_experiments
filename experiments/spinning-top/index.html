<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spin Art - Drawing Top</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            min-height: 100vh;
            min-height: 100dvh;
            color: #fff;
            display: flex;
            overflow: hidden;
        }

        .toolbar {
            width: 60px;
            background: #252542;
            display: flex;
            flex-direction: column;
            padding: 10px 5px;
            gap: 5px;
            border-right: 1px solid #333;
            flex-shrink: 0;
        }

        .tool-btn {
            width: 48px;
            height: 48px;
            border: none;
            border-radius: 8px;
            background: #333;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: background 0.2s;
        }

        .tool-btn:hover {
            background: #444;
        }

        .tool-btn.active {
            background: #4a6fa5;
            box-shadow: 0 0 10px rgba(74, 111, 165, 0.5);
        }

        .separator {
            height: 1px;
            background: #444;
            margin: 5px 0;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background: radial-gradient(circle, #252542 0%, #1a1a2e 100%);
            min-width: 0;
            padding: 10px;
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .canvas-label {
            font-size: 0.75em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .drawing-canvas {
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0,0,0,0.5), 0 0 60px rgba(74, 111, 165, 0.15);
            cursor: crosshair;
            touch-action: none;
        }

        #staticCanvas {
            border: 2px solid #4a6fa5;
        }

        #spinningCanvas {
            border: 2px solid #e74c3c;
        }

        .controls {
            width: 280px;
            background: #252542;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border-left: 1px solid #333;
            overflow-y: auto;
            flex-shrink: 0;
        }

        h2 {
            font-size: 0.9em;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 5px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-row label {
            font-size: 0.85em;
            color: #aaa;
            min-width: 70px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #444;
            outline: none;
            -webkit-appearance: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a6fa5;
            cursor: pointer;
        }

        .slider-row input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a6fa5;
            cursor: pointer;
            border: none;
        }

        .slider-row span {
            font-size: 0.85em;
            color: #4a6fa5;
            min-width: 50px;
            text-align: right;
        }

        select {
            width: 100%;
            padding: 8px;
            border-radius: 6px;
            border: none;
            background: #333;
            color: #fff;
            font-size: 0.9em;
            cursor: pointer;
        }

        select option {
            background: #252542;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 5px;
        }

        .palette-color {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
        }

        .palette-color:hover {
            border-color: #666;
        }

        .palette-color.selected {
            border-color: #fff;
        }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: transparent;
        }

        .btn {
            padding: 10px 15px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .btn:hover {
            transform: translateY(-1px);
        }

        .btn-stop {
            background: #e74c3c;
            color: #fff;
            font-weight: bold;
        }

        .btn-spin {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: #fff;
            font-weight: bold;
        }

        .btn-clear {
            background: #c0392b;
            color: #fff;
        }

        .btn-fill-bg {
            background: #2980b9;
            color: #fff;
        }

        .btn-load {
            background: #8e44ad;
            color: #fff;
        }

        .btn-photo {
            background: #27ae60;
            color: #fff;
        }

        .btn-row {
            display: flex;
            gap: 8px;
        }

        .btn-row .btn {
            flex: 1;
        }

        .stats {
            font-size: 0.8em;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        .keyboard-hint {
            font-size: 0.75em;
            color: #555;
            line-height: 1.6;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid #333;
        }

        .keyboard-hint kbd {
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Mobile Layout */
        @media (max-width: 1100px) {
            .canvas-area {
                flex-direction: column;
                gap: 10px;
            }
        }

        @media (max-width: 900px) {
            body {
                flex-direction: column;
            }

            .toolbar {
                width: 100%;
                flex-direction: row;
                justify-content: center;
                padding: 8px;
                border-right: none;
                border-bottom: 1px solid #333;
                order: 2;
                flex-wrap: wrap;
            }

            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .separator {
                width: 1px;
                height: 30px;
                margin: 0 5px;
            }

            .canvas-area {
                order: 1;
                flex: 1;
                min-height: 0;
                flex-direction: row;
            }

            .controls {
                width: 100%;
                max-height: 35vh;
                border-left: none;
                border-top: 1px solid #333;
                order: 3;
                padding: 12px;
                gap: 10px;
            }

            .keyboard-hint {
                display: none;
            }

            h2 {
                font-size: 0.8em;
            }

            .color-palette {
                grid-template-columns: repeat(8, 1fr);
            }

            .canvas-label {
                display: none;
            }
        }

        @media (max-width: 600px) {
            .toolbar {
                padding: 6px;
                gap: 3px;
            }

            .tool-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
            }

            .controls {
                padding: 10px;
                gap: 8px;
            }

            .slider-row label {
                min-width: 55px;
                font-size: 0.8em;
            }

            .slider-row span {
                min-width: 40px;
                font-size: 0.8em;
            }

            .color-palette {
                grid-template-columns: repeat(6, 1fr);
            }

            .btn {
                padding: 8px 10px;
                font-size: 0.85em;
            }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            body {
                flex-direction: row;
            }

            .toolbar {
                width: 50px;
                flex-direction: column;
                border-bottom: none;
                border-right: 1px solid #333;
                order: 1;
                padding: 5px;
                flex-wrap: nowrap;
            }

            .tool-btn {
                width: 40px;
                height: 40px;
            }

            .separator {
                width: auto;
                height: 1px;
                margin: 3px 0;
            }

            .canvas-area {
                order: 2;
                flex-direction: row;
            }

            .controls {
                width: 200px;
                max-height: none;
                border-top: none;
                border-left: 1px solid #333;
                order: 3;
                padding: 8px;
            }

            .color-palette {
                grid-template-columns: repeat(4, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <button class="tool-btn active" data-tool="pencil" title="Pencil (P)">‚úèÔ∏è</button>
        <button class="tool-btn" data-tool="line" title="Line (L)">üìè</button>
        <button class="tool-btn" data-tool="fill" title="Fill (F)">ü™£</button>
        <button class="tool-btn" data-tool="eraser" title="Eraser (E)">üßΩ</button>
        <div class="separator"></div>
        <button class="tool-btn" data-tool="circle" title="Circle (C)">‚≠ï</button>
        <button class="tool-btn" data-tool="rect" title="Rectangle (R)">‚¨ú</button>
    </div>

    <div class="canvas-area">
        <div class="canvas-wrapper">
            <span class="canvas-label">Static</span>
            <canvas id="staticCanvas" class="drawing-canvas" width="600" height="600"></canvas>
        </div>
        <div class="canvas-wrapper">
            <span class="canvas-label">Spinning</span>
            <canvas id="spinningCanvas" class="drawing-canvas" width="600" height="600"></canvas>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <h2>Speed</h2>
            <div class="slider-row">
                <label>RPM</label>
                <input type="range" id="speed" min="-500" max="500" value="0">
                <span id="speedValue">0</span>
            </div>
            <div class="btn-row">
                <button class="btn btn-spin" onclick="spinIt()">SPIN!</button>
                <button class="btn btn-stop" onclick="stopSpin()">STOP</button>
            </div>
            <div class="slider-row">
                <label>Friction</label>
                <input type="range" id="friction" min="0" max="100" value="50">
                <span id="frictionValue">50%</span>
            </div>
        </div>

        <div class="control-group">
            <h2>Symmetry</h2>
            <select id="symmetry">
                <option value="none">None</option>
                <option value="mirror-h">Mirror (Horizontal)</option>
                <option value="mirror-v">Mirror (Vertical)</option>
                <option value="point">Point (180¬∞)</option>
                <option value="radial-3">Radial 3</option>
                <option value="radial-4">Radial 4</option>
                <option value="radial-5">Radial 5</option>
                <option value="radial-6">Radial 6</option>
                <option value="radial-8">Radial 8</option>
                <option value="radial-12">Radial 12</option>
            </select>
        </div>

        <div class="control-group">
            <h2>Brush</h2>
            <div class="slider-row">
                <label>Size</label>
                <input type="range" id="brushSize" min="1" max="50" value="8">
                <span id="brushSizeValue">8px</span>
            </div>
            <div class="slider-row">
                <label>Opacity</label>
                <input type="range" id="opacity" min="10" max="100" value="100">
                <span id="opacityValue">100%</span>
            </div>
        </div>

        <div class="control-group">
            <h2>Color</h2>
            <div class="color-palette" id="palette"></div>
            <input type="color" id="colorPicker" value="#ffffff">
        </div>

        <div class="control-group">
            <h2>Canvas</h2>
            <div class="slider-row">
                <label>Background</label>
                <input type="color" id="bgColor" value="#1a1a2e">
            </div>
            <div class="btn-row">
                <button class="btn btn-fill-bg" onclick="fillBackground()">Fill BG</button>
                <button class="btn btn-clear" onclick="clearCanvas()">Clear</button>
            </div>
            <div class="btn-row">
                <button class="btn btn-load" onclick="document.getElementById('imageInput').click()">Load Image</button>
                <button class="btn btn-photo" onclick="document.getElementById('cameraInput').click()">Photo</button>
            </div>
            <input type="file" id="imageInput" accept="image/*" style="display:none">
            <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
        </div>

        <div class="stats">
            <span>Rotation: <span id="rotation">0¬∞</span></span>
            <span id="fps">60 FPS</span>
        </div>

        <div class="keyboard-hint">
            <kbd>P</kbd> Pencil
            <kbd>L</kbd> Line
            <kbd>F</kbd> Fill
            <kbd>E</kbd> Eraser<br>
            <kbd>C</kbd> Circle
            <kbd>R</kbd> Rectangle<br>
            <kbd>Space</kbd> Spin/Stop
        </div>
    </div>

    <!-- Hidden canvas for drawing -->
    <canvas id="drawCanvas" width="600" height="600" style="display:none;"></canvas>

    <script>
        const staticCanvas = document.getElementById('staticCanvas');
        const staticCtx = staticCanvas.getContext('2d');
        const spinningCanvas = document.getElementById('spinningCanvas');
        const spinningCtx = spinningCanvas.getContext('2d');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');

        // Constants
        const CANVAS_SIZE = 600;
        const SNAP_THRESHOLD = 20;

        // State
        let angle = 0;
        let rpm = 0;
        let targetRpm = 0;
        let friction = 0.5;
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;
        let staticCanvasScale = 1;
        let spinningCanvasScale = 1;

        // Drawing state
        let currentTool = 'pencil';
        let isDrawing = false;
        let activeCanvas = null;
        let lastX = 0;
        let lastY = 0;
        let startX = 0;
        let startY = 0;
        let currentColor = '#ffffff';
        let brushSize = 8;
        let opacity = 1;
        let symmetry = 'none';

        // For shape preview
        let previewCanvas = document.createElement('canvas');
        previewCanvas.width = CANVAS_SIZE;
        previewCanvas.height = CANVAS_SIZE;
        let previewCtx = previewCanvas.getContext('2d');

        // Color palette
        const colors = [
            '#ffffff', '#c0c0c0', '#808080', '#000000', '#ff0000', '#800000',
            '#ffff00', '#808000', '#00ff00', '#008000', '#00ffff', '#008080',
            '#0000ff', '#000080', '#ff00ff', '#800080', '#ff6b6b', '#feca57',
            '#48dbfb', '#1dd1a1', '#5f27cd', '#ff9f43', '#ee5a24', '#009432'
        ];

        // Initialize palette
        const paletteEl = document.getElementById('palette');
        colors.forEach((color, i) => {
            const div = document.createElement('div');
            div.className = 'palette-color' + (i === 0 ? ' selected' : '');
            div.style.background = color;
            div.onclick = () => selectColor(color, div);
            paletteEl.appendChild(div);
        });

        function selectColor(color, el) {
            currentColor = color;
            document.getElementById('colorPicker').value = color;
            document.querySelectorAll('.palette-color').forEach(p => p.classList.remove('selected'));
            if (el) el.classList.add('selected');
        }

        document.getElementById('colorPicker').addEventListener('input', (e) => {
            currentColor = e.target.value;
            document.querySelectorAll('.palette-color').forEach(p => p.classList.remove('selected'));
        });

        // Tool selection
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        // Speed slider with snap-to-zero
        const speedSlider = document.getElementById('speed');
        speedSlider.addEventListener('input', (e) => {
            let value = parseInt(e.target.value);
            if (Math.abs(value) <= SNAP_THRESHOLD) {
                value = 0;
                e.target.value = 0;
            }
            targetRpm = value;
            rpm = value;
            document.getElementById('speedValue').textContent = value;
        });

        // Friction slider
        document.getElementById('friction').addEventListener('input', (e) => {
            friction = parseInt(e.target.value) / 100;
            document.getElementById('frictionValue').textContent = e.target.value + '%';
        });

        // Symmetry selector
        document.getElementById('symmetry').addEventListener('change', (e) => {
            symmetry = e.target.value;
        });

        // Spin button - give it a push
        function spinIt() {
            const direction = Math.random() > 0.5 ? 1 : -1;
            rpm = direction * (300 + Math.random() * 200);
            targetRpm = 0; // Will decelerate
            updateSpeedDisplay();
        }

        // Stop button
        function stopSpin() {
            rpm = 0;
            targetRpm = 0;
            updateSpeedDisplay();
        }

        function updateSpeedDisplay() {
            document.getElementById('speed').value = Math.round(rpm);
            document.getElementById('speedValue').textContent = Math.round(rpm);
        }

        document.getElementById('brushSize').addEventListener('input', (e) => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize + 'px';
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacityValue').textContent = e.target.value + '%';
        });

        // Resize handler
        function resizeCanvases() {
            const container = document.querySelector('.canvas-area');
            const isVertical = container.offsetWidth < 700;

            let availableWidth, availableHeight;
            if (isVertical) {
                availableWidth = container.clientWidth - 20;
                availableHeight = (container.clientHeight - 40) / 2;
            } else {
                availableWidth = (container.clientWidth - 40) / 2;
                availableHeight = container.clientHeight - 40;
            }

            const size = Math.min(availableWidth, availableHeight, 400);

            staticCanvas.style.width = size + 'px';
            staticCanvas.style.height = size + 'px';
            spinningCanvas.style.width = size + 'px';
            spinningCanvas.style.height = size + 'px';

            staticCanvasScale = CANVAS_SIZE / size;
            spinningCanvasScale = CANVAS_SIZE / size;
        }

        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        // Get coordinates accounting for canvas scale and rotation
        function getDrawCoords(e, canvas, applyRotation = false) {
            const rect = canvas.getBoundingClientRect();
            const scale = canvas === staticCanvas ? staticCanvasScale : spinningCanvasScale;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (applyRotation) {
                const cx = CANVAS_SIZE / 2;
                const cy = CANVAS_SIZE / 2;
                const dx = x - cx;
                const dy = y - cy;
                const cos = Math.cos(-angle);
                const sin = Math.sin(-angle);
                return {
                    x: cx + dx * cos - dy * sin,
                    y: cy + dx * sin + dy * cos
                };
            }

            return { x, y };
        }

        // Get symmetry points
        function getSymmetryPoints(x, y) {
            const cx = CANVAS_SIZE / 2;
            const cy = CANVAS_SIZE / 2;
            const dx = x - cx;
            const dy = y - cy;
            const points = [{ x, y }];

            if (symmetry === 'none') {
                return points;
            }

            if (symmetry === 'mirror-h') {
                points.push({ x: cx - dx, y });
            } else if (symmetry === 'mirror-v') {
                points.push({ x, y: cy - dy });
            } else if (symmetry === 'point') {
                points.push({ x: cx - dx, y: cy - dy });
            } else if (symmetry.startsWith('radial-')) {
                const n = parseInt(symmetry.split('-')[1]);
                for (let i = 1; i < n; i++) {
                    const angle = (i / n) * Math.PI * 2;
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    points.push({
                        x: cx + dx * cos - dy * sin,
                        y: cy + dx * sin + dy * cos
                    });
                }
            }

            return points;
        }

        // Drawing functions
        function startDrawing(e, canvas) {
            isDrawing = true;
            activeCanvas = canvas;
            const applyRotation = canvas === spinningCanvas;
            const coords = getDrawCoords(e, canvas, applyRotation);
            lastX = coords.x;
            lastY = coords.y;
            startX = coords.x;
            startY = coords.y;

            if (currentTool === 'fill') {
                floodFill(Math.round(coords.x), Math.round(coords.y), currentColor);
                isDrawing = false;
            } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawDot(coords.x, coords.y);
            }
        }

        function draw(e) {
            if (!isDrawing || !activeCanvas) return;

            const applyRotation = activeCanvas === spinningCanvas;
            const coords = getDrawCoords(e, activeCanvas, applyRotation);

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawLineWithSymmetry(lastX, lastY, coords.x, coords.y);
                lastX = coords.x;
                lastY = coords.y;
            } else if (currentTool === 'line' || currentTool === 'circle' || currentTool === 'rect') {
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                previewCtx.drawImage(drawCanvas, 0, 0);
                drawShapeWithSymmetry(previewCtx, startX, startY, coords.x, coords.y);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;

            if (activeCanvas && (currentTool === 'line' || currentTool === 'circle' || currentTool === 'rect')) {
                const applyRotation = activeCanvas === spinningCanvas;
                const coords = getDrawCoords(e, activeCanvas, applyRotation);
                drawShapeWithSymmetry(drawCtx, startX, startY, coords.x, coords.y);
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            isDrawing = false;
            activeCanvas = null;
        }

        function drawDot(x, y) {
            const points = getSymmetryPoints(x, y);
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : currentColor;

            drawCtx.globalAlpha = opacity;
            drawCtx.fillStyle = color;

            points.forEach(p => {
                drawCtx.beginPath();
                drawCtx.arc(p.x, p.y, brushSize / 2, 0, Math.PI * 2);
                drawCtx.fill();
            });

            drawCtx.globalAlpha = 1;
        }

        function drawLineWithSymmetry(x1, y1, x2, y2) {
            const points1 = getSymmetryPoints(x1, y1);
            const points2 = getSymmetryPoints(x2, y2);
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : currentColor;

            drawCtx.globalAlpha = opacity;
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = brushSize;
            drawCtx.lineCap = 'round';
            drawCtx.lineJoin = 'round';

            for (let i = 0; i < points1.length; i++) {
                drawCtx.beginPath();
                drawCtx.moveTo(points1[i].x, points1[i].y);
                drawCtx.lineTo(points2[i].x, points2[i].y);
                drawCtx.stroke();
            }

            drawCtx.globalAlpha = 1;
        }

        function drawShapeWithSymmetry(ctx, x1, y1, x2, y2) {
            const points1 = getSymmetryPoints(x1, y1);
            const points2 = getSymmetryPoints(x2, y2);

            ctx.globalAlpha = opacity;
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';

            for (let i = 0; i < points1.length; i++) {
                const p1 = points1[i];
                const p2 = points2[i];

                if (currentTool === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                } else if (currentTool === 'circle') {
                    const radius = Math.sqrt((p2.x - p1.x) ** 2 + (p2.y - p1.y) ** 2);
                    ctx.beginPath();
                    ctx.arc(p1.x, p1.y, radius, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (currentTool === 'rect') {
                    ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                }
            }

            ctx.globalAlpha = 1;
        }

        // Flood fill algorithm
        function floodFill(startX, startY, fillColor) {
            const imageData = drawCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;

            const startIdx = (startY * CANVAS_SIZE + startX) * 4;
            const startR = data[startIdx];
            const startG = data[startIdx + 1];
            const startB = data[startIdx + 2];

            const fill = hexToRgb(fillColor);
            if (!fill) return;

            if (startR === fill.r && startG === fill.g && startB === fill.b) return;

            const stack = [[startX, startY]];
            const visited = new Set();

            while (stack.length > 0) {
                const [x, y] = stack.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                if (x < 0 || x >= CANVAS_SIZE || y < 0 || y >= CANVAS_SIZE) continue;

                const idx = (y * CANVAS_SIZE + x) * 4;

                if (Math.abs(data[idx] - startR) > 10 ||
                    Math.abs(data[idx + 1] - startG) > 10 ||
                    Math.abs(data[idx + 2] - startB) > 10) {
                    continue;
                }

                visited.add(key);

                data[idx] = fill.r;
                data[idx + 1] = fill.g;
                data[idx + 2] = fill.b;
                data[idx + 3] = 255;

                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }

            drawCtx.putImageData(imageData, 0, 0);
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        // Event listeners for both canvases
        [staticCanvas, spinningCanvas].forEach(canvas => {
            canvas.addEventListener('mousedown', (e) => startDrawing(e, canvas));
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                startDrawing({ clientX: touch.clientX, clientY: touch.clientY }, canvas);
            }, { passive: false });
        });

        document.addEventListener('mousemove', draw);
        document.addEventListener('mouseup', stopDrawing);

        document.addEventListener('touchmove', (e) => {
            if (!isDrawing) return;
            e.preventDefault();
            const touch = e.touches[0];
            draw({ clientX: touch.clientX, clientY: touch.clientY });
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (!isDrawing) return;
            e.preventDefault();
            if (e.changedTouches.length > 0) {
                const touch = e.changedTouches[0];
                stopDrawing({ clientX: touch.clientX, clientY: touch.clientY });
            } else {
                isDrawing = false;
                activeCanvas = null;
            }
        }, { passive: false });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;

            switch(e.key.toLowerCase()) {
                case 'p': selectTool('pencil'); break;
                case 'l': selectTool('line'); break;
                case 'f': selectTool('fill'); break;
                case 'e': selectTool('eraser'); break;
                case 'c': selectTool('circle'); break;
                case 'r': selectTool('rect'); break;
                case '[':
                    brushSize = Math.max(1, brushSize - 2);
                    document.getElementById('brushSize').value = brushSize;
                    document.getElementById('brushSizeValue').textContent = brushSize + 'px';
                    break;
                case ']':
                    brushSize = Math.min(50, brushSize + 2);
                    document.getElementById('brushSize').value = brushSize;
                    document.getElementById('brushSizeValue').textContent = brushSize + 'px';
                    break;
                case ' ':
                    e.preventDefault();
                    if (Math.abs(rpm) < 10) {
                        spinIt();
                    } else {
                        stopSpin();
                    }
                    break;
            }
        });

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.tool === tool);
            });
        }

        // Canvas functions
        function clearCanvas() {
            const bg = document.getElementById('bgColor').value;
            drawCtx.fillStyle = bg;
            drawCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        function fillBackground() {
            const bg = document.getElementById('bgColor').value;
            drawCtx.fillStyle = bg;
            drawCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
        }

        // Initialize
        clearCanvas();

        // Image loading
        function loadImage(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const scale = Math.max(CANVAS_SIZE / img.width, CANVAS_SIZE / img.height);
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const x = (CANVAS_SIZE - w) / 2;
                    const y = (CANVAS_SIZE - h) / 2;
                    drawCtx.drawImage(img, x, y, w, h);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('imageInput').addEventListener('change', (e) => {
            loadImage(e.target.files[0]);
            e.target.value = '';
        });

        document.getElementById('cameraInput').addEventListener('change', (e) => {
            loadImage(e.target.files[0]);
            e.target.value = '';
        });

        // Main animation loop
        function animate(timestamp) {
            const deltaTime = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // Apply friction when decelerating
            if (targetRpm === 0 && rpm !== 0) {
                const frictionForce = friction * 200 * deltaTime;
                if (Math.abs(rpm) < frictionForce) {
                    rpm = 0;
                } else {
                    rpm -= Math.sign(rpm) * frictionForce;
                }
                updateSpeedDisplay();
            }

            // Update rotation
            angle += (rpm / 60) * Math.PI * 2 * deltaTime;

            // Draw static canvas (no rotation)
            staticCtx.fillStyle = '#1a1a2e';
            staticCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            if (isDrawing && activeCanvas === staticCanvas &&
                (currentTool === 'line' || currentTool === 'circle' || currentTool === 'rect')) {
                staticCtx.drawImage(previewCanvas, 0, 0);
            } else {
                staticCtx.drawImage(drawCanvas, 0, 0);
            }

            // Clip static to circle
            staticCtx.globalCompositeOperation = 'destination-in';
            staticCtx.beginPath();
            staticCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            staticCtx.fill();
            staticCtx.globalCompositeOperation = 'source-over';

            // Draw spinning canvas (with rotation)
            spinningCtx.fillStyle = '#1a1a2e';
            spinningCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            spinningCtx.save();
            spinningCtx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
            spinningCtx.rotate(angle);
            spinningCtx.translate(-CANVAS_SIZE / 2, -CANVAS_SIZE / 2);

            if (isDrawing && activeCanvas === spinningCanvas &&
                (currentTool === 'line' || currentTool === 'circle' || currentTool === 'rect')) {
                spinningCtx.drawImage(previewCanvas, 0, 0);
            } else {
                spinningCtx.drawImage(drawCanvas, 0, 0);
            }

            spinningCtx.restore();

            // Clip spinning to circle
            spinningCtx.globalCompositeOperation = 'destination-in';
            spinningCtx.beginPath();
            spinningCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            spinningCtx.fill();
            spinningCtx.globalCompositeOperation = 'source-over';

            // Update stats
            document.getElementById('rotation').textContent = Math.round((angle * 180 / Math.PI) % 360) + '¬∞';

            // FPS counter
            frameCount++;
            if (timestamp - lastFpsTime > 1000) {
                document.getElementById('fps').textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsTime = timestamp;
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
