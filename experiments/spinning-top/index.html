<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spin Art - Drawing Top</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a15;
            height: 100vh;
            height: 100dvh;
            color: #fff;
            display: flex;
            overflow: hidden;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            background: radial-gradient(ellipse at center, #151528 0%, #0a0a15 100%);
            min-width: 0;
            padding: 15px;
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            position: relative;
        }

        .canvas-label {
            font-size: 0.7em;
            color: #555;
            text-transform: uppercase;
        }

        .canvas-container {
            position: relative;
        }

        .drawing-canvas {
            border-radius: 50%;
            cursor: crosshair;
            touch-action: none;
            position: relative;
            z-index: 2;
        }

        .particle-canvas {
            position: absolute;
            top: 0;
            left: 0;
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
        }

        #staticCanvas { box-shadow: 0 0 40px rgba(74, 111, 165, 0.3), inset 0 0 60px rgba(74, 111, 165, 0.1); border: 2px solid #4a6fa5; }
        #spinningCanvas { box-shadow: 0 0 40px rgba(231, 76, 60, 0.3), inset 0 0 60px rgba(231, 76, 60, 0.1); border: 2px solid #e74c3c; }

        .sidebar {
            width: 280px;
            background: linear-gradient(180deg, #151528 0%, #0d0d1a 100%);
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-left: 1px solid #252542;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .section {
            background: linear-gradient(135deg, #1a1a30 0%, #12121f 100%);
            border-radius: 8px;
            padding: 8px;
            border: 1px solid #252545;
        }

        .section-title {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .tool-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 6px;
            background: #252545;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.15s;
        }

        .tool-btn:hover { background: #353565; box-shadow: 0 0 10px rgba(100, 100, 200, 0.3); }
        .tool-btn.active {
            background: linear-gradient(135deg, #4a6fa5 0%, #5f27cd 100%);
            box-shadow: 0 0 15px rgba(95, 39, 205, 0.5);
        }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .tool-btn.neon-active {
            animation: neonPulse 1.5s infinite;
        }

        @keyframes neonPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 255, 0.5), 0 0 20px rgba(255, 0, 255, 0.3); }
            50% { box-shadow: 0 0 20px rgba(0, 255, 255, 0.8), 0 0 40px rgba(255, 0, 255, 0.6); }
        }

        .row { display: flex; gap: 6px; align-items: center; }
        .row > * { flex: 1; }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .slider-row label {
            font-size: 0.75em;
            color: #888;
            min-width: 50px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: linear-gradient(90deg, #252545 0%, #353565 100%);
            -webkit-appearance: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a6fa5 0%, #5f27cd 100%);
            cursor: pointer;
            box-shadow: 0 0 8px rgba(95, 39, 205, 0.5);
        }

        .slider-row span {
            font-size: 0.75em;
            color: #00ffff;
            min-width: 35px;
            text-align: right;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        select {
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #353565;
            background: #252545;
            color: #fff;
            font-size: 0.8em;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
        }

        .color-swatch {
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .color-swatch:hover { border-color: #666; transform: scale(1.1); }
        .color-swatch.selected { border-color: #fff; box-shadow: 0 0 10px currentColor; }

        input[type="color"] {
            width: 100%;
            height: 28px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            margin-top: 4px;
        }

        .btn {
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.15s;
            font-weight: 500;
        }

        .btn:hover { transform: translateY(-1px); }
        .btn-spin {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            color: #fff;
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.4);
        }
        .btn-stop { background: #e74c3c; color: #fff; box-shadow: 0 0 10px rgba(231, 76, 60, 0.4); }
        .btn-action { background: linear-gradient(135deg, #252545 0%, #353565 100%); color: #fff; border: 1px solid #454575; }
        .btn-danger { background: linear-gradient(135deg, #c0392b 0%, #8b0000 100%); color: #fff; }
        .btn-neon {
            background: linear-gradient(135deg, #00ffff 0%, #ff00ff 100%);
            color: #000;
            font-weight: bold;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        .btn-export {
            background: linear-gradient(135deg, #00ff88 0%, #00aa55 100%);
            color: #000;
            font-weight: bold;
        }

        .speed-presets {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .speed-preset {
            padding: 4px 8px;
            font-size: 0.7em;
            border-radius: 4px;
            border: 1px solid #353565;
            background: #252545;
            color: #888;
            cursor: pointer;
            transition: all 0.15s;
        }

        .speed-preset:hover {
            background: #353565;
            color: #fff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }

        .stats {
            font-size: 0.7em;
            color: #555;
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
        }

        .recording-indicator {
            display: none;
            align-items: center;
            gap: 4px;
            color: #ff0000;
            font-size: 0.75em;
        }

        .recording-indicator.active {
            display: flex;
            animation: recordBlink 1s infinite;
        }

        @keyframes recordBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .record-dot {
            width: 8px;
            height: 8px;
            background: #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff0000;
        }

        /* Toggle switches */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
        }

        .toggle-label {
            font-size: 0.75em;
            color: #888;
        }

        .toggle {
            width: 36px;
            height: 20px;
            background: #252545;
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }

        .toggle.active {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
        }

        .toggle::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: left 0.2s;
        }

        .toggle.active::after {
            left: 18px;
        }

        /* Mobile */
        @media (max-width: 900px) {
            body { flex-direction: column; }

            .canvas-area {
                flex: 1;
                min-height: 0;
                padding: 8px;
                gap: 8px;
            }

            .canvas-label { display: none; }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid #252542;
                padding: 8px;
                gap: 6px;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .section {
                flex: 1 1 calc(50% - 4px);
                min-width: 140px;
                padding: 6px;
            }

            .section.full-width { flex: 1 1 100%; }

            .tool-grid { grid-template-columns: repeat(8, 1fr); }

            .color-grid { grid-template-columns: repeat(12, 1fr); }

            .section-title { font-size: 0.65em; margin-bottom: 4px; }
            .btn { padding: 6px; font-size: 0.75em; }
            .slider-row label { min-width: 40px; font-size: 0.7em; }
            .slider-row span { min-width: 28px; font-size: 0.7em; }
        }

        @media (max-width: 500px) {
            .sidebar { max-height: 45vh; }
            .section { flex: 1 1 100%; }
            .tool-grid { grid-template-columns: repeat(8, 1fr); }
            .tool-btn { font-size: 14px; }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            body { flex-direction: row; }

            .canvas-area { flex-direction: row; }

            .sidebar {
                width: 220px;
                max-height: none;
                flex-direction: column;
                border-top: none;
                border-left: 1px solid #252542;
            }

            .section { flex: 0 0 auto; }
            .color-grid { grid-template-columns: repeat(6, 1fr); }
        }

        /* Larger canvas for desktop */
        @media (min-width: 1200px) {
            .canvas-area { gap: 30px; }
        }

        @media (min-width: 1600px) {
            .sidebar { width: 320px; }
            .canvas-area { gap: 40px; }
        }
    </style>
</head>
<body>
    <div class="canvas-area">
        <div class="canvas-wrapper">
            <span class="canvas-label">Static</span>
            <div class="canvas-container">
                <canvas id="staticCanvas" class="drawing-canvas" width="600" height="600"></canvas>
                <canvas id="staticParticles" class="particle-canvas" width="600" height="600"></canvas>
            </div>
        </div>
        <div class="canvas-wrapper">
            <span class="canvas-label">Spinning</span>
            <div class="canvas-container">
                <canvas id="spinningCanvas" class="drawing-canvas" width="600" height="600"></canvas>
                <canvas id="spinningParticles" class="particle-canvas" width="600" height="600"></canvas>
            </div>
        </div>
    </div>

    <div class="sidebar">
        <div class="section">
            <div class="section-title">Tools</div>
            <div class="tool-grid">
                <button class="tool-btn active" data-tool="pencil" title="Pencil (P)">‚úèÔ∏è</button>
                <button class="tool-btn" data-tool="line" title="Line (L)">üìè</button>
                <button class="tool-btn" data-tool="circle" title="Circle (C)">‚≠ï</button>
                <button class="tool-btn" data-tool="rect" title="Rectangle (R)">‚¨ú</button>
                <button class="tool-btn" data-tool="fill" title="Fill (F)">ü™£</button>
                <button class="tool-btn" data-tool="eraser" title="Eraser (E)">üßΩ</button>
                <button class="tool-btn" id="undoBtn" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
                <button class="tool-btn" id="redoBtn" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Spin</div>
            <div class="slider-row">
                <label>RPM</label>
                <input type="range" id="speed" min="-500" max="500" value="0">
                <span id="speedValue">0</span>
            </div>
            <div class="speed-presets">
                <button class="speed-preset" onclick="setSpeed(-120)">-120</button>
                <button class="speed-preset" onclick="setSpeed(-60)">-60</button>
                <button class="speed-preset" onclick="setSpeed(0)">0</button>
                <button class="speed-preset" onclick="setSpeed(60)">60</button>
                <button class="speed-preset" onclick="setSpeed(120)">120</button>
                <button class="speed-preset" onclick="setSpeed(300)">300</button>
            </div>
            <div class="row" style="margin-top:6px">
                <button class="btn btn-spin" onclick="spinIt()">SPIN!</button>
                <button class="btn btn-stop" onclick="stopSpin()">STOP</button>
            </div>
            <div class="slider-row" style="margin-top:6px">
                <label>Friction</label>
                <input type="range" id="friction" min="0" max="100" value="50">
                <span id="frictionValue">50%</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Brush</div>
            <div class="slider-row">
                <label>Size</label>
                <input type="range" id="brushSize" min="1" max="50" value="8">
                <span id="brushSizeValue">8</span>
            </div>
            <div class="slider-row">
                <label>Opacity</label>
                <input type="range" id="opacity" min="10" max="100" value="100">
                <span id="opacityValue">100%</span>
            </div>
            <select id="symmetry" style="margin-top:6px">
                <option value="none">No Symmetry</option>
                <option value="mirror-h">Mirror H</option>
                <option value="mirror-v">Mirror V</option>
                <option value="point">Point 180¬∞</option>
                <option value="radial-3">Radial 3</option>
                <option value="radial-4">Radial 4</option>
                <option value="radial-6">Radial 6</option>
                <option value="radial-8">Radial 8</option>
                <option value="radial-12">Radial 12</option>
            </select>
            <div class="toggle-row" style="margin-top:6px">
                <span class="toggle-label">Rainbow Brush</span>
                <div class="toggle" id="rainbowToggle" onclick="toggleRainbow()"></div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Color</div>
            <div class="color-grid" id="palette"></div>
            <input type="color" id="colorPicker" value="#ffffff">
        </div>

        <div class="section">
            <div class="section-title">Effects</div>
            <div class="toggle-row">
                <span class="toggle-label">Neon Glow</span>
                <div class="toggle active" id="glowToggle" onclick="toggleGlow()"></div>
            </div>
            <div class="toggle-row">
                <span class="toggle-label">Particles</span>
                <div class="toggle active" id="particleToggle" onclick="toggleParticles()"></div>
            </div>
            <div class="slider-row" style="margin-top:6px">
                <label>Glow</label>
                <input type="range" id="glowIntensity" min="0" max="50" value="20">
                <span id="glowValue">20</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Canvas</div>
            <div class="row">
                <button class="btn btn-action" onclick="document.getElementById('imageInput').click()">Load</button>
                <button class="btn btn-action" onclick="document.getElementById('cameraInput').click()">Photo</button>
                <button class="btn btn-danger" onclick="clearCanvas()">Clear</button>
            </div>
            <input type="file" id="imageInput" accept="image/*" style="display:none">
            <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
            <div class="slider-row" style="margin-top:6px">
                <label>BG</label>
                <input type="color" id="bgColor" value="#0a0a15" style="flex:1;height:24px">
            </div>
        </div>

        <div class="section">
            <div class="section-title">Export</div>
            <div class="row">
                <button class="btn btn-export" onclick="exportPNG()">PNG</button>
                <button class="btn btn-neon" id="recordBtn" onclick="toggleRecording()">REC</button>
            </div>
            <div class="recording-indicator" id="recordingIndicator">
                <div class="record-dot"></div>
                <span id="recordTime">0:00</span>
            </div>
        </div>

        <div class="stats">
            <span>Rot: <span id="rotation">0¬∞</span></span>
            <span id="fps">60 FPS</span>
            <span>History: <span id="historyCount">0/0</span></span>
        </div>
    </div>

    <canvas id="drawCanvas" width="600" height="600" style="display:none"></canvas>
    <canvas id="exportCanvas" width="600" height="600" style="display:none"></canvas>

    <script>
        const staticCanvas = document.getElementById('staticCanvas');
        const staticCtx = staticCanvas.getContext('2d');
        const spinningCanvas = document.getElementById('spinningCanvas');
        const spinningCtx = spinningCanvas.getContext('2d');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const staticParticles = document.getElementById('staticParticles');
        const staticParticlesCtx = staticParticles.getContext('2d');
        const spinningParticles = document.getElementById('spinningParticles');
        const spinningParticlesCtx = spinningParticles.getContext('2d');
        const exportCanvas = document.getElementById('exportCanvas');
        const exportCtx = exportCanvas.getContext('2d');

        const CANVAS_SIZE = 600;
        const SNAP_THRESHOLD = 20;
        const MAX_HISTORY = 50;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;

        // State
        let angle = 0, rpm = 0, targetRpm = 0, friction = 0.5;
        let lastTime = 0, frameCount = 0, lastFpsTime = 0;
        let canvasScale = 1;

        // Drawing
        let currentTool = 'pencil', isDrawing = false, activeCanvas = null;
        let lastX = 0, lastY = 0, startX = 0, startY = 0;
        let currentColor = '#ffffff', brushSize = 8, opacity = 1, symmetry = 'none';
        let rainbowMode = false, rainbowHue = 0;

        // Effects
        let glowEnabled = true, glowIntensity = 20;
        let particlesEnabled = true;
        let particles = [];

        // Recording
        let isRecording = false, recordedFrames = [], recordStartTime = 0;

        // Preview canvas
        let previewCanvas = document.createElement('canvas');
        previewCanvas.width = previewCanvas.height = CANVAS_SIZE;
        let previewCtx = previewCanvas.getContext('2d');

        // Particle system - toroidal flow
        class Particle {
            constructor() {
                this.reset();
            }

            reset() {
                const a = Math.random() * Math.PI * 2;
                this.angle = a;
                this.radius = Math.random() * 30 + 10;
                this.speed = Math.random() * 2 + 1;
                this.size = Math.random() * 3 + 1;
                this.hue = Math.random() * 360;
                this.alpha = Math.random() * 0.5 + 0.3;
                this.z = Math.random(); // depth for 3D effect
            }

            update(dt) {
                // Toroidal motion: spiral outward then reset
                this.radius += this.speed * dt * 60;
                this.angle += (0.02 + (rpm / 1000)) * dt * 60;
                this.hue = (this.hue + 1) % 360;

                // Fade out as approaching edge
                const maxRadius = CANVAS_SIZE / 2 - 20;
                if (this.radius > maxRadius * 0.7) {
                    this.alpha = Math.max(0, this.alpha - 0.02);
                }

                if (this.radius > maxRadius || this.alpha <= 0) {
                    this.reset();
                }
            }

            draw(ctx, centerX, centerY, rotationAngle = 0) {
                const x = centerX + Math.cos(this.angle + rotationAngle) * this.radius;
                const y = centerY + Math.sin(this.angle + rotationAngle) * this.radius;

                ctx.beginPath();
                ctx.arc(x, y, this.size * (0.5 + this.z * 0.5), 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${this.alpha})`;
                ctx.shadowColor = `hsl(${this.hue}, 100%, 60%)`;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Initialize particles
        for (let i = 0; i < 100; i++) {
            particles.push(new Particle());
        }

        // Colors - neon palette
        const colors = [
            '#ffffff','#ff00ff','#00ffff','#ff0080','#00ff80','#8000ff','#ff8000','#80ff00',
            '#ff0000','#ff4400','#ffff00','#00ff00','#00ff88','#0088ff','#0000ff','#4400ff',
            '#ff00aa','#aa00ff','#ff6600','#ffcc00','#ccff00','#00ffcc','#00ccff','#cc00ff'
        ];

        const paletteEl = document.getElementById('palette');
        colors.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = 'color-swatch' + (i === 0 ? ' selected' : '');
            div.style.background = c;
            div.style.boxShadow = `0 0 8px ${c}40`;
            div.onclick = () => {
                currentColor = c;
                document.getElementById('colorPicker').value = c;
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                div.classList.add('selected');
            };
            paletteEl.appendChild(div);
        });

        document.getElementById('colorPicker').addEventListener('input', e => {
            currentColor = e.target.value;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        });

        // Tools
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        // Sliders
        document.getElementById('speed').addEventListener('input', e => {
            let v = parseInt(e.target.value);
            if (Math.abs(v) <= SNAP_THRESHOLD) { v = 0; e.target.value = 0; }
            rpm = targetRpm = v;
            document.getElementById('speedValue').textContent = v;
        });

        document.getElementById('friction').addEventListener('input', e => {
            friction = parseInt(e.target.value) / 100;
            document.getElementById('frictionValue').textContent = e.target.value + '%';
        });

        document.getElementById('brushSize').addEventListener('input', e => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('opacity').addEventListener('input', e => {
            opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacityValue').textContent = e.target.value + '%';
        });

        document.getElementById('glowIntensity').addEventListener('input', e => {
            glowIntensity = parseInt(e.target.value);
            document.getElementById('glowValue').textContent = glowIntensity;
        });

        document.getElementById('symmetry').addEventListener('change', e => symmetry = e.target.value);

        function setSpeed(v) {
            rpm = targetRpm = v;
            updateSpeedDisplay();
        }

        function spinIt() {
            rpm = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 200);
            targetRpm = 0;
            updateSpeedDisplay();
        }

        function stopSpin() {
            rpm = targetRpm = 0;
            updateSpeedDisplay();
        }

        function updateSpeedDisplay() {
            document.getElementById('speed').value = Math.round(rpm);
            document.getElementById('speedValue').textContent = Math.round(rpm);
        }

        function toggleRainbow() {
            rainbowMode = !rainbowMode;
            document.getElementById('rainbowToggle').classList.toggle('active', rainbowMode);
        }

        function toggleGlow() {
            glowEnabled = !glowEnabled;
            document.getElementById('glowToggle').classList.toggle('active', glowEnabled);
        }

        function toggleParticles() {
            particlesEnabled = !particlesEnabled;
            document.getElementById('particleToggle').classList.toggle('active', particlesEnabled);
        }

        // History
        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const imgData = drawCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            history.push(imgData);
            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                drawCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                drawCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            document.getElementById('historyCount').textContent = `${historyIndex + 1}/${history.length}`;
        }

        // Resize - larger for desktop
        function resizeCanvases() {
            const container = document.querySelector('.canvas-area');
            const isVertical = container.offsetWidth < 700;
            let w, h;
            if (isVertical) {
                w = container.clientWidth - 16;
                h = (container.clientHeight - 24) / 2;
            } else {
                w = (container.clientWidth - 40) / 2;
                h = container.clientHeight - 20;
            }

            // Larger canvas for desktop
            let maxSize = 350;
            if (window.innerWidth >= 1200) maxSize = 450;
            if (window.innerWidth >= 1600) maxSize = 550;

            const size = Math.min(w, h, maxSize);

            [staticCanvas, spinningCanvas, staticParticles, spinningParticles].forEach(c => {
                c.style.width = c.style.height = size + 'px';
            });

            canvasScale = CANVAS_SIZE / size;
        }
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        function getDrawCoords(e, canvas, rotate = false) {
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left) * canvasScale;
            let y = (e.clientY - rect.top) * canvasScale;
            if (rotate) {
                const cx = CANVAS_SIZE / 2, cy = CANVAS_SIZE / 2;
                const dx = x - cx, dy = y - cy;
                const cos = Math.cos(-angle), sin = Math.sin(-angle);
                x = cx + dx * cos - dy * sin;
                y = cy + dx * sin + dy * cos;
            }
            return { x, y };
        }

        function getSymmetryPoints(x, y) {
            const cx = CANVAS_SIZE / 2, cy = CANVAS_SIZE / 2;
            const dx = x - cx, dy = y - cy;
            const pts = [{ x, y }];
            if (symmetry === 'none') return pts;
            if (symmetry === 'mirror-h') pts.push({ x: cx - dx, y });
            else if (symmetry === 'mirror-v') pts.push({ x, y: cy - dy });
            else if (symmetry === 'point') pts.push({ x: cx - dx, y: cy - dy });
            else if (symmetry.startsWith('radial-')) {
                const n = parseInt(symmetry.split('-')[1]);
                for (let i = 1; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    pts.push({ x: cx + dx * Math.cos(a) - dy * Math.sin(a), y: cy + dx * Math.sin(a) + dy * Math.cos(a) });
                }
            }
            return pts;
        }

        function getCurrentColor() {
            if (rainbowMode) {
                rainbowHue = (rainbowHue + 2) % 360;
                return `hsl(${rainbowHue}, 100%, 50%)`;
            }
            return currentColor;
        }

        function startDrawing(e, canvas) {
            isDrawing = true;
            activeCanvas = canvas;
            const coords = getDrawCoords(e, canvas, canvas === spinningCanvas);
            lastX = startX = coords.x;
            lastY = startY = coords.y;
            if (currentTool === 'fill') {
                floodFill(Math.round(coords.x), Math.round(coords.y), getCurrentColor());
                isDrawing = false;
                saveState();
            } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawDot(coords.x, coords.y);
            }
        }

        function draw(e) {
            if (!isDrawing || !activeCanvas) return;
            const coords = getDrawCoords(e, activeCanvas, activeCanvas === spinningCanvas);
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawLineSymmetric(lastX, lastY, coords.x, coords.y);
                lastX = coords.x; lastY = coords.y;
            } else if (['line', 'circle', 'rect'].includes(currentTool)) {
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                previewCtx.drawImage(drawCanvas, 0, 0);
                drawShapeSymmetric(previewCtx, startX, startY, coords.x, coords.y);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            if (activeCanvas && ['line', 'circle', 'rect'].includes(currentTool)) {
                const coords = getDrawCoords(e, activeCanvas, activeCanvas === spinningCanvas);
                drawShapeSymmetric(drawCtx, startX, startY, coords.x, coords.y);
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            if (isDrawing) saveState();
            isDrawing = false;
            activeCanvas = null;
        }

        function drawDot(x, y) {
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : getCurrentColor();
            drawCtx.globalAlpha = opacity;
            drawCtx.fillStyle = color;

            if (glowEnabled && currentTool !== 'eraser') {
                drawCtx.shadowColor = color;
                drawCtx.shadowBlur = glowIntensity;
            }

            getSymmetryPoints(x, y).forEach(p => {
                drawCtx.beginPath();
                drawCtx.arc(p.x, p.y, brushSize / 2, 0, Math.PI * 2);
                drawCtx.fill();
            });

            drawCtx.shadowBlur = 0;
            drawCtx.globalAlpha = 1;
        }

        function drawLineSymmetric(x1, y1, x2, y2) {
            const pts1 = getSymmetryPoints(x1, y1), pts2 = getSymmetryPoints(x2, y2);
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : getCurrentColor();
            drawCtx.globalAlpha = opacity;
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = brushSize;
            drawCtx.lineCap = drawCtx.lineJoin = 'round';

            if (glowEnabled && currentTool !== 'eraser') {
                drawCtx.shadowColor = color;
                drawCtx.shadowBlur = glowIntensity;
            }

            for (let i = 0; i < pts1.length; i++) {
                drawCtx.beginPath();
                drawCtx.moveTo(pts1[i].x, pts1[i].y);
                drawCtx.lineTo(pts2[i].x, pts2[i].y);
                drawCtx.stroke();
            }

            drawCtx.shadowBlur = 0;
            drawCtx.globalAlpha = 1;
        }

        function drawShapeSymmetric(ctx, x1, y1, x2, y2) {
            const pts1 = getSymmetryPoints(x1, y1), pts2 = getSymmetryPoints(x2, y2);
            const color = getCurrentColor();
            ctx.globalAlpha = opacity;
            ctx.strokeStyle = color;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';

            if (glowEnabled) {
                ctx.shadowColor = color;
                ctx.shadowBlur = glowIntensity;
            }

            for (let i = 0; i < pts1.length; i++) {
                const p1 = pts1[i], p2 = pts2[i];
                ctx.beginPath();
                if (currentTool === 'line') {
                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                } else if (currentTool === 'circle') {
                    ctx.arc(p1.x, p1.y, Math.hypot(p2.x - p1.x, p2.y - p1.y), 0, Math.PI * 2); ctx.stroke();
                } else if (currentTool === 'rect') {
                    ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                }
            }

            ctx.shadowBlur = 0;
            ctx.globalAlpha = 1;
        }

        function floodFill(sx, sy, fillColor) {
            const img = drawCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const d = img.data, idx = (sy * CANVAS_SIZE + sx) * 4;
            const sR = d[idx], sG = d[idx + 1], sB = d[idx + 2];
            const fill = parseColor(fillColor);
            if (!fill || (sR === fill.r && sG === fill.g && sB === fill.b)) return;
            const stack = [[sx, sy]], visited = new Set();
            while (stack.length) {
                const [x, y] = stack.pop(), key = `${x},${y}`;
                if (visited.has(key) || x < 0 || x >= CANVAS_SIZE || y < 0 || y >= CANVAS_SIZE) continue;
                const i = (y * CANVAS_SIZE + x) * 4;
                if (Math.abs(d[i] - sR) > 10 || Math.abs(d[i + 1] - sG) > 10 || Math.abs(d[i + 2] - sB) > 10) continue;
                visited.add(key);
                d[i] = fill.r; d[i + 1] = fill.g; d[i + 2] = fill.b; d[i + 3] = 255;
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            drawCtx.putImageData(img, 0, 0);
        }

        function parseColor(color) {
            // Handle hex
            const hexMatch = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
            if (hexMatch) {
                return { r: parseInt(hexMatch[1], 16), g: parseInt(hexMatch[2], 16), b: parseInt(hexMatch[3], 16) };
            }
            // Handle hsl
            const hslMatch = /hsl\((\d+),\s*(\d+)%,\s*(\d+)%\)/.exec(color);
            if (hslMatch) {
                return hslToRgb(parseInt(hslMatch[1]), parseInt(hslMatch[2]), parseInt(hslMatch[3]));
            }
            return null;
        }

        function hslToRgb(h, s, l) {
            s /= 100; l /= 100;
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const x = c * (1 - Math.abs((h / 60) % 2 - 1));
            const m = l - c / 2;
            let r, g, b;
            if (h < 60) { r = c; g = x; b = 0; }
            else if (h < 120) { r = x; g = c; b = 0; }
            else if (h < 180) { r = 0; g = c; b = x; }
            else if (h < 240) { r = 0; g = x; b = c; }
            else if (h < 300) { r = x; g = 0; b = c; }
            else { r = c; g = 0; b = x; }
            return { r: Math.round((r + m) * 255), g: Math.round((g + m) * 255), b: Math.round((b + m) * 255) };
        }

        [staticCanvas, spinningCanvas].forEach(c => {
            c.addEventListener('mousedown', e => startDrawing(e, c));
            c.addEventListener('touchstart', e => { e.preventDefault(); startDrawing({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }, c); }, { passive: false });
        });

        document.addEventListener('mousemove', draw);
        document.addEventListener('mouseup', stopDrawing);
        document.addEventListener('touchmove', e => { if (isDrawing) { e.preventDefault(); draw({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }); } }, { passive: false });
        document.addEventListener('touchend', e => { if (isDrawing) { e.preventDefault(); stopDrawing(e.changedTouches[0] ? { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY } : {}); } }, { passive: false });

        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            const key = e.key.toLowerCase();
            if (key === 'z' && (e.ctrlKey || e.metaKey)) { e.shiftKey ? redo() : undo(); e.preventDefault(); }
            else if (key === 'y' && (e.ctrlKey || e.metaKey)) { redo(); e.preventDefault(); }
            else if (key === ' ') { e.preventDefault(); Math.abs(rpm) < 10 ? spinIt() : stopSpin(); }
            else if (key === 'p') document.querySelector('[data-tool="pencil"]').click();
            else if (key === 'l') document.querySelector('[data-tool="line"]').click();
            else if (key === 'c') document.querySelector('[data-tool="circle"]').click();
            else if (key === 'r') document.querySelector('[data-tool="rect"]').click();
            else if (key === 'f') document.querySelector('[data-tool="fill"]').click();
            else if (key === 'e') document.querySelector('[data-tool="eraser"]').click();
            else if (key === 'g') toggleGlow();
            else if (key === 'n') toggleParticles();
            else if (key === 'b') toggleRainbow();
        });

        function clearCanvas() {
            drawCtx.fillStyle = document.getElementById('bgColor').value;
            drawCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            saveState();
        }

        function loadImage(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    const scale = Math.max(CANVAS_SIZE / img.width, CANVAS_SIZE / img.height);
                    const w = img.width * scale, h = img.height * scale;
                    drawCtx.drawImage(img, (CANVAS_SIZE - w) / 2, (CANVAS_SIZE - h) / 2, w, h);
                    saveState();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('imageInput').addEventListener('change', e => { loadImage(e.target.files[0]); e.target.value = ''; });
        document.getElementById('cameraInput').addEventListener('change', e => { loadImage(e.target.files[0]); e.target.value = ''; });

        // Export functions
        function exportPNG() {
            // Combine spinning canvas view with particles
            exportCtx.fillStyle = document.getElementById('bgColor').value;
            exportCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            exportCtx.save();
            exportCtx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
            exportCtx.rotate(angle);
            exportCtx.translate(-CANVAS_SIZE / 2, -CANVAS_SIZE / 2);
            exportCtx.drawImage(drawCanvas, 0, 0);
            exportCtx.restore();

            // Clip to circle
            exportCtx.globalCompositeOperation = 'destination-in';
            exportCtx.beginPath();
            exportCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            exportCtx.fill();
            exportCtx.globalCompositeOperation = 'source-over';

            const link = document.createElement('a');
            link.download = `spin-art-${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        }

        let mediaRecorder, recordedChunks = [];

        function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            recordedChunks = [];
            const stream = spinningCanvas.captureStream(30);
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });

            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                const blob = new Blob(recordedChunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `spin-art-${Date.now()}.webm`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            };

            mediaRecorder.start();
            isRecording = true;
            recordStartTime = Date.now();
            document.getElementById('recordBtn').textContent = 'STOP';
            document.getElementById('recordBtn').classList.add('btn-stop');
            document.getElementById('recordBtn').classList.remove('btn-neon');
            document.getElementById('recordingIndicator').classList.add('active');
            updateRecordTime();
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            isRecording = false;
            document.getElementById('recordBtn').textContent = 'REC';
            document.getElementById('recordBtn').classList.remove('btn-stop');
            document.getElementById('recordBtn').classList.add('btn-neon');
            document.getElementById('recordingIndicator').classList.remove('active');
        }

        function updateRecordTime() {
            if (!isRecording) return;
            const elapsed = Math.floor((Date.now() - recordStartTime) / 1000);
            const mins = Math.floor(elapsed / 60);
            const secs = elapsed % 60;
            document.getElementById('recordTime').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
            requestAnimationFrame(updateRecordTime);
        }

        // Init
        clearCanvas();

        function animate(ts) {
            const dt = (ts - lastTime) / 1000;
            lastTime = ts;

            if (targetRpm === 0 && rpm !== 0) {
                const f = friction * 200 * dt;
                rpm = Math.abs(rpm) < f ? 0 : rpm - Math.sign(rpm) * f;
                updateSpeedDisplay();
            }

            angle += (rpm / 60) * Math.PI * 2 * dt;

            // Update particles
            if (particlesEnabled) {
                particles.forEach(p => p.update(dt));
            }

            const bgColor = document.getElementById('bgColor').value;
            const cx = CANVAS_SIZE / 2, cy = CANVAS_SIZE / 2;

            // Static canvas
            staticCtx.fillStyle = bgColor;
            staticCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            staticCtx.drawImage(isDrawing && activeCanvas === staticCanvas && ['line', 'circle', 'rect'].includes(currentTool) ? previewCanvas : drawCanvas, 0, 0);
            staticCtx.globalCompositeOperation = 'destination-in';
            staticCtx.beginPath();
            staticCtx.arc(cx, cy, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            staticCtx.fill();
            staticCtx.globalCompositeOperation = 'source-over';

            // Spinning canvas
            spinningCtx.fillStyle = bgColor;
            spinningCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            spinningCtx.save();
            spinningCtx.translate(cx, cy);
            spinningCtx.rotate(angle);
            spinningCtx.translate(-cx, -cy);
            spinningCtx.drawImage(isDrawing && activeCanvas === spinningCanvas && ['line', 'circle', 'rect'].includes(currentTool) ? previewCanvas : drawCanvas, 0, 0);
            spinningCtx.restore();
            spinningCtx.globalCompositeOperation = 'destination-in';
            spinningCtx.beginPath();
            spinningCtx.arc(cx, cy, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            spinningCtx.fill();
            spinningCtx.globalCompositeOperation = 'source-over';

            // Draw particles
            if (particlesEnabled) {
                staticParticlesCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                spinningParticlesCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

                particles.forEach(p => {
                    p.draw(staticParticlesCtx, cx, cy, 0);
                    p.draw(spinningParticlesCtx, cx, cy, angle);
                });
            } else {
                staticParticlesCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                spinningParticlesCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            document.getElementById('rotation').textContent = Math.round((angle * 180 / Math.PI) % 360) + '¬∞';

            frameCount++;
            if (ts - lastFpsTime > 1000) {
                document.getElementById('fps').textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsTime = ts;
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
