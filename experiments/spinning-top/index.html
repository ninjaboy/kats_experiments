<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Spin Art - Drawing Top</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            height: 100vh;
            height: 100dvh;
            color: #fff;
            display: flex;
            overflow: hidden;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            background: radial-gradient(circle, #252542 0%, #1a1a2e 100%);
            min-width: 0;
            padding: 10px;
        }

        .canvas-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .canvas-label {
            font-size: 0.7em;
            color: #555;
            text-transform: uppercase;
        }

        .drawing-canvas {
            border-radius: 50%;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            cursor: crosshair;
            touch-action: none;
        }

        #staticCanvas { border: 2px solid #4a6fa5; }
        #spinningCanvas { border: 2px solid #e74c3c; }

        .sidebar {
            width: 260px;
            background: #252542;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            border-left: 1px solid #333;
            overflow-y: auto;
            flex-shrink: 0;
        }

        .section {
            background: #1e1e38;
            border-radius: 6px;
            padding: 8px;
        }

        .section-title {
            font-size: 0.7em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 6px;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 4px;
        }

        .tool-btn {
            aspect-ratio: 1;
            border: none;
            border-radius: 6px;
            background: #333;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: background 0.15s;
        }

        .tool-btn:hover { background: #444; }
        .tool-btn.active {
            background: #4a6fa5;
            box-shadow: 0 0 8px rgba(74, 111, 165, 0.4);
        }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        .row { display: flex; gap: 6px; align-items: center; }
        .row > * { flex: 1; }

        .slider-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .slider-row label {
            font-size: 0.75em;
            color: #888;
            min-width: 50px;
        }

        .slider-row input[type="range"] {
            flex: 1;
            height: 4px;
            border-radius: 2px;
            background: #444;
            -webkit-appearance: none;
        }

        .slider-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #4a6fa5;
            cursor: pointer;
        }

        .slider-row span {
            font-size: 0.75em;
            color: #4a6fa5;
            min-width: 35px;
            text-align: right;
        }

        select {
            width: 100%;
            padding: 6px;
            border-radius: 4px;
            border: none;
            background: #333;
            color: #fff;
            font-size: 0.8em;
        }

        .color-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 3px;
        }

        .color-swatch {
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 3px;
            cursor: pointer;
        }

        .color-swatch:hover { border-color: #666; }
        .color-swatch.selected { border-color: #fff; }

        input[type="color"] {
            width: 100%;
            height: 28px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            margin-top: 4px;
        }

        .btn {
            padding: 8px;
            border: none;
            border-radius: 4px;
            font-size: 0.8em;
            cursor: pointer;
            transition: transform 0.1s;
            font-weight: 500;
        }

        .btn:hover { transform: translateY(-1px); }
        .btn-spin { background: linear-gradient(135deg, #f39c12, #e74c3c); color: #fff; }
        .btn-stop { background: #e74c3c; color: #fff; }
        .btn-action { background: #333; color: #fff; }
        .btn-danger { background: #c0392b; color: #fff; }

        .stats {
            font-size: 0.7em;
            color: #555;
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
        }

        /* Mobile */
        @media (max-width: 800px) {
            body { flex-direction: column; }

            .canvas-area {
                flex: 1;
                min-height: 0;
                padding: 8px;
                gap: 8px;
            }

            .canvas-label { display: none; }

            .sidebar {
                width: 100%;
                max-height: 40vh;
                border-left: none;
                border-top: 1px solid #333;
                padding: 8px;
                gap: 6px;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .section {
                flex: 1 1 calc(50% - 4px);
                min-width: 140px;
                padding: 6px;
            }

            .section.full-width { flex: 1 1 100%; }

            .tool-grid { grid-template-columns: repeat(8, 1fr); }

            .color-grid { grid-template-columns: repeat(12, 1fr); }

            .section-title { font-size: 0.65em; margin-bottom: 4px; }
            .btn { padding: 6px; font-size: 0.75em; }
            .slider-row label { min-width: 40px; font-size: 0.7em; }
            .slider-row span { min-width: 28px; font-size: 0.7em; }
        }

        @media (max-width: 500px) {
            .sidebar { max-height: 45vh; }
            .section { flex: 1 1 100%; }
            .tool-grid { grid-template-columns: repeat(8, 1fr); }
            .tool-btn { font-size: 14px; }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            body { flex-direction: row; }

            .canvas-area { flex-direction: row; }

            .sidebar {
                width: 220px;
                max-height: none;
                flex-direction: column;
                border-top: none;
                border-left: 1px solid #333;
            }

            .section { flex: 0 0 auto; }
            .color-grid { grid-template-columns: repeat(6, 1fr); }
        }
    </style>
</head>
<body>
    <div class="canvas-area">
        <div class="canvas-wrapper">
            <span class="canvas-label">Static</span>
            <canvas id="staticCanvas" class="drawing-canvas" width="600" height="600"></canvas>
        </div>
        <div class="canvas-wrapper">
            <span class="canvas-label">Spinning</span>
            <canvas id="spinningCanvas" class="drawing-canvas" width="600" height="600"></canvas>
        </div>
    </div>

    <div class="sidebar">
        <div class="section">
            <div class="section-title">Tools</div>
            <div class="tool-grid">
                <button class="tool-btn active" data-tool="pencil" title="Pencil">‚úèÔ∏è</button>
                <button class="tool-btn" data-tool="line" title="Line">üìè</button>
                <button class="tool-btn" data-tool="circle" title="Circle">‚≠ï</button>
                <button class="tool-btn" data-tool="rect" title="Rectangle">‚¨ú</button>
                <button class="tool-btn" data-tool="fill" title="Fill">ü™£</button>
                <button class="tool-btn" data-tool="eraser" title="Eraser">üßΩ</button>
                <button class="tool-btn" id="undoBtn" onclick="undo()" title="Undo">‚Ü©Ô∏è</button>
                <button class="tool-btn" id="redoBtn" onclick="redo()" title="Redo">‚Ü™Ô∏è</button>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Spin</div>
            <div class="slider-row">
                <label>RPM</label>
                <input type="range" id="speed" min="-500" max="500" value="0">
                <span id="speedValue">0</span>
            </div>
            <div class="row" style="margin-top:6px">
                <button class="btn btn-spin" onclick="spinIt()">SPIN!</button>
                <button class="btn btn-stop" onclick="stopSpin()">STOP</button>
            </div>
            <div class="slider-row" style="margin-top:6px">
                <label>Friction</label>
                <input type="range" id="friction" min="0" max="100" value="50">
                <span id="frictionValue">50%</span>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Brush</div>
            <div class="slider-row">
                <label>Size</label>
                <input type="range" id="brushSize" min="1" max="50" value="8">
                <span id="brushSizeValue">8</span>
            </div>
            <div class="slider-row">
                <label>Opacity</label>
                <input type="range" id="opacity" min="10" max="100" value="100">
                <span id="opacityValue">100%</span>
            </div>
            <select id="symmetry" style="margin-top:6px">
                <option value="none">No Symmetry</option>
                <option value="mirror-h">Mirror H</option>
                <option value="mirror-v">Mirror V</option>
                <option value="point">Point 180¬∞</option>
                <option value="radial-3">Radial 3</option>
                <option value="radial-4">Radial 4</option>
                <option value="radial-6">Radial 6</option>
                <option value="radial-8">Radial 8</option>
                <option value="radial-12">Radial 12</option>
            </select>
        </div>

        <div class="section">
            <div class="section-title">Color</div>
            <div class="color-grid" id="palette"></div>
            <input type="color" id="colorPicker" value="#ffffff">
        </div>

        <div class="section">
            <div class="section-title">Canvas</div>
            <div class="row">
                <button class="btn btn-action" onclick="document.getElementById('imageInput').click()">Load</button>
                <button class="btn btn-action" onclick="document.getElementById('cameraInput').click()">Photo</button>
                <button class="btn btn-danger" onclick="clearCanvas()">Clear</button>
            </div>
            <input type="file" id="imageInput" accept="image/*" style="display:none">
            <input type="file" id="cameraInput" accept="image/*" capture="environment" style="display:none">
            <div class="slider-row" style="margin-top:6px">
                <label>BG</label>
                <input type="color" id="bgColor" value="#1a1a2e" style="flex:1;height:24px">
            </div>
        </div>

        <div class="stats">
            <span>Rot: <span id="rotation">0¬∞</span></span>
            <span id="fps">60 FPS</span>
            <span>History: <span id="historyCount">0/0</span></span>
        </div>
    </div>

    <canvas id="drawCanvas" width="600" height="600" style="display:none"></canvas>

    <script>
        const staticCanvas = document.getElementById('staticCanvas');
        const staticCtx = staticCanvas.getContext('2d');
        const spinningCanvas = document.getElementById('spinningCanvas');
        const spinningCtx = spinningCanvas.getContext('2d');
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');

        const CANVAS_SIZE = 600;
        const SNAP_THRESHOLD = 20;
        const MAX_HISTORY = 50;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;

        // State
        let angle = 0, rpm = 0, targetRpm = 0, friction = 0.5;
        let lastTime = 0, frameCount = 0, lastFpsTime = 0;
        let canvasScale = 1;

        // Drawing
        let currentTool = 'pencil', isDrawing = false, activeCanvas = null;
        let lastX = 0, lastY = 0, startX = 0, startY = 0;
        let currentColor = '#ffffff', brushSize = 8, opacity = 1, symmetry = 'none';

        // Preview canvas
        let previewCanvas = document.createElement('canvas');
        previewCanvas.width = previewCanvas.height = CANVAS_SIZE;
        let previewCtx = previewCanvas.getContext('2d');

        // Colors
        const colors = [
            '#ffffff','#c0c0c0','#808080','#000000','#ff0000','#800000','#ff6b6b','#feca57',
            '#ffff00','#808000','#00ff00','#008000','#48dbfb','#1dd1a1','#00ffff','#008080',
            '#0000ff','#000080','#ff00ff','#800080','#5f27cd','#ff9f43','#ee5a24','#009432'
        ];

        const paletteEl = document.getElementById('palette');
        colors.forEach((c, i) => {
            const div = document.createElement('div');
            div.className = 'color-swatch' + (i === 0 ? ' selected' : '');
            div.style.background = c;
            div.onclick = () => {
                currentColor = c;
                document.getElementById('colorPicker').value = c;
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                div.classList.add('selected');
            };
            paletteEl.appendChild(div);
        });

        document.getElementById('colorPicker').addEventListener('input', e => {
            currentColor = e.target.value;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        });

        // Tools
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tool-btn[data-tool]').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentTool = btn.dataset.tool;
            });
        });

        // Sliders
        document.getElementById('speed').addEventListener('input', e => {
            let v = parseInt(e.target.value);
            if (Math.abs(v) <= SNAP_THRESHOLD) { v = 0; e.target.value = 0; }
            rpm = targetRpm = v;
            document.getElementById('speedValue').textContent = v;
        });

        document.getElementById('friction').addEventListener('input', e => {
            friction = parseInt(e.target.value) / 100;
            document.getElementById('frictionValue').textContent = e.target.value + '%';
        });

        document.getElementById('brushSize').addEventListener('input', e => {
            brushSize = parseInt(e.target.value);
            document.getElementById('brushSizeValue').textContent = brushSize;
        });

        document.getElementById('opacity').addEventListener('input', e => {
            opacity = parseInt(e.target.value) / 100;
            document.getElementById('opacityValue').textContent = e.target.value + '%';
        });

        document.getElementById('symmetry').addEventListener('change', e => symmetry = e.target.value);

        function spinIt() {
            rpm = (Math.random() > 0.5 ? 1 : -1) * (300 + Math.random() * 200);
            targetRpm = 0;
            updateSpeedDisplay();
        }

        function stopSpin() {
            rpm = targetRpm = 0;
            updateSpeedDisplay();
        }

        function updateSpeedDisplay() {
            document.getElementById('speed').value = Math.round(rpm);
            document.getElementById('speedValue').textContent = Math.round(rpm);
        }

        // History
        function saveState() {
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            const imgData = drawCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            history.push(imgData);
            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                drawCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                drawCtx.putImageData(history[historyIndex], 0, 0);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            document.getElementById('undoBtn').disabled = historyIndex <= 0;
            document.getElementById('redoBtn').disabled = historyIndex >= history.length - 1;
            document.getElementById('historyCount').textContent = `${historyIndex + 1}/${history.length}`;
        }

        // Resize
        function resizeCanvases() {
            const container = document.querySelector('.canvas-area');
            const isVertical = container.offsetWidth < 600;
            let w, h;
            if (isVertical) {
                w = container.clientWidth - 16;
                h = (container.clientHeight - 24) / 2;
            } else {
                w = (container.clientWidth - 24) / 2;
                h = container.clientHeight - 16;
            }
            const size = Math.min(w, h, 350);
            staticCanvas.style.width = staticCanvas.style.height = size + 'px';
            spinningCanvas.style.width = spinningCanvas.style.height = size + 'px';
            canvasScale = CANVAS_SIZE / size;
        }
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();

        function getDrawCoords(e, canvas, rotate = false) {
            const rect = canvas.getBoundingClientRect();
            let x = (e.clientX - rect.left) * canvasScale;
            let y = (e.clientY - rect.top) * canvasScale;
            if (rotate) {
                const cx = CANVAS_SIZE / 2, cy = CANVAS_SIZE / 2;
                const dx = x - cx, dy = y - cy;
                const cos = Math.cos(-angle), sin = Math.sin(-angle);
                x = cx + dx * cos - dy * sin;
                y = cy + dx * sin + dy * cos;
            }
            return { x, y };
        }

        function getSymmetryPoints(x, y) {
            const cx = CANVAS_SIZE / 2, cy = CANVAS_SIZE / 2;
            const dx = x - cx, dy = y - cy;
            const pts = [{ x, y }];
            if (symmetry === 'none') return pts;
            if (symmetry === 'mirror-h') pts.push({ x: cx - dx, y });
            else if (symmetry === 'mirror-v') pts.push({ x, y: cy - dy });
            else if (symmetry === 'point') pts.push({ x: cx - dx, y: cy - dy });
            else if (symmetry.startsWith('radial-')) {
                const n = parseInt(symmetry.split('-')[1]);
                for (let i = 1; i < n; i++) {
                    const a = (i / n) * Math.PI * 2;
                    pts.push({ x: cx + dx * Math.cos(a) - dy * Math.sin(a), y: cy + dx * Math.sin(a) + dy * Math.cos(a) });
                }
            }
            return pts;
        }

        function startDrawing(e, canvas) {
            isDrawing = true;
            activeCanvas = canvas;
            const coords = getDrawCoords(e, canvas, canvas === spinningCanvas);
            lastX = startX = coords.x;
            lastY = startY = coords.y;
            if (currentTool === 'fill') {
                floodFill(Math.round(coords.x), Math.round(coords.y), currentColor);
                isDrawing = false;
                saveState();
            } else if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawDot(coords.x, coords.y);
            }
        }

        function draw(e) {
            if (!isDrawing || !activeCanvas) return;
            const coords = getDrawCoords(e, activeCanvas, activeCanvas === spinningCanvas);
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawLineSymmetric(lastX, lastY, coords.x, coords.y);
                lastX = coords.x; lastY = coords.y;
            } else if (['line', 'circle', 'rect'].includes(currentTool)) {
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                previewCtx.drawImage(drawCanvas, 0, 0);
                drawShapeSymmetric(previewCtx, startX, startY, coords.x, coords.y);
            }
        }

        function stopDrawing(e) {
            if (!isDrawing) return;
            if (activeCanvas && ['line', 'circle', 'rect'].includes(currentTool)) {
                const coords = getDrawCoords(e, activeCanvas, activeCanvas === spinningCanvas);
                drawShapeSymmetric(drawCtx, startX, startY, coords.x, coords.y);
                previewCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
            if (isDrawing) saveState();
            isDrawing = false;
            activeCanvas = null;
        }

        function drawDot(x, y) {
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : currentColor;
            drawCtx.globalAlpha = opacity;
            drawCtx.fillStyle = color;
            getSymmetryPoints(x, y).forEach(p => {
                drawCtx.beginPath();
                drawCtx.arc(p.x, p.y, brushSize / 2, 0, Math.PI * 2);
                drawCtx.fill();
            });
            drawCtx.globalAlpha = 1;
        }

        function drawLineSymmetric(x1, y1, x2, y2) {
            const pts1 = getSymmetryPoints(x1, y1), pts2 = getSymmetryPoints(x2, y2);
            const color = currentTool === 'eraser' ? document.getElementById('bgColor').value : currentColor;
            drawCtx.globalAlpha = opacity;
            drawCtx.strokeStyle = color;
            drawCtx.lineWidth = brushSize;
            drawCtx.lineCap = drawCtx.lineJoin = 'round';
            for (let i = 0; i < pts1.length; i++) {
                drawCtx.beginPath();
                drawCtx.moveTo(pts1[i].x, pts1[i].y);
                drawCtx.lineTo(pts2[i].x, pts2[i].y);
                drawCtx.stroke();
            }
            drawCtx.globalAlpha = 1;
        }

        function drawShapeSymmetric(ctx, x1, y1, x2, y2) {
            const pts1 = getSymmetryPoints(x1, y1), pts2 = getSymmetryPoints(x2, y2);
            ctx.globalAlpha = opacity;
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = 'round';
            for (let i = 0; i < pts1.length; i++) {
                const p1 = pts1[i], p2 = pts2[i];
                ctx.beginPath();
                if (currentTool === 'line') {
                    ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                } else if (currentTool === 'circle') {
                    ctx.arc(p1.x, p1.y, Math.hypot(p2.x - p1.x, p2.y - p1.y), 0, Math.PI * 2); ctx.stroke();
                } else if (currentTool === 'rect') {
                    ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
                }
            }
            ctx.globalAlpha = 1;
        }

        function floodFill(sx, sy, fillColor) {
            const img = drawCtx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const d = img.data, idx = (sy * CANVAS_SIZE + sx) * 4;
            const sR = d[idx], sG = d[idx + 1], sB = d[idx + 2];
            const fill = hexToRgb(fillColor);
            if (!fill || (sR === fill.r && sG === fill.g && sB === fill.b)) return;
            const stack = [[sx, sy]], visited = new Set();
            while (stack.length) {
                const [x, y] = stack.pop(), key = `${x},${y}`;
                if (visited.has(key) || x < 0 || x >= CANVAS_SIZE || y < 0 || y >= CANVAS_SIZE) continue;
                const i = (y * CANVAS_SIZE + x) * 4;
                if (Math.abs(d[i] - sR) > 10 || Math.abs(d[i + 1] - sG) > 10 || Math.abs(d[i + 2] - sB) > 10) continue;
                visited.add(key);
                d[i] = fill.r; d[i + 1] = fill.g; d[i + 2] = fill.b; d[i + 3] = 255;
                stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
            }
            drawCtx.putImageData(img, 0, 0);
        }

        function hexToRgb(hex) {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : null;
        }

        [staticCanvas, spinningCanvas].forEach(c => {
            c.addEventListener('mousedown', e => startDrawing(e, c));
            c.addEventListener('touchstart', e => { e.preventDefault(); startDrawing({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }, c); }, { passive: false });
        });

        document.addEventListener('mousemove', draw);
        document.addEventListener('mouseup', stopDrawing);
        document.addEventListener('touchmove', e => { if (isDrawing) { e.preventDefault(); draw({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY }); } }, { passive: false });
        document.addEventListener('touchend', e => { if (isDrawing) { e.preventDefault(); stopDrawing(e.changedTouches[0] ? { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY } : {}); } }, { passive: false });

        document.addEventListener('keydown', e => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') return;
            const key = e.key.toLowerCase();
            if (key === 'z' && (e.ctrlKey || e.metaKey)) { e.shiftKey ? redo() : undo(); e.preventDefault(); }
            else if (key === 'y' && (e.ctrlKey || e.metaKey)) { redo(); e.preventDefault(); }
            else if (key === ' ') { e.preventDefault(); Math.abs(rpm) < 10 ? spinIt() : stopSpin(); }
        });

        function clearCanvas() {
            drawCtx.fillStyle = document.getElementById('bgColor').value;
            drawCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            saveState();
        }

        function loadImage(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                const img = new Image();
                img.onload = () => {
                    const scale = Math.max(CANVAS_SIZE / img.width, CANVAS_SIZE / img.height);
                    const w = img.width * scale, h = img.height * scale;
                    drawCtx.drawImage(img, (CANVAS_SIZE - w) / 2, (CANVAS_SIZE - h) / 2, w, h);
                    saveState();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('imageInput').addEventListener('change', e => { loadImage(e.target.files[0]); e.target.value = ''; });
        document.getElementById('cameraInput').addEventListener('change', e => { loadImage(e.target.files[0]); e.target.value = ''; });

        // Init
        clearCanvas();

        function animate(ts) {
            const dt = (ts - lastTime) / 1000;
            lastTime = ts;

            if (targetRpm === 0 && rpm !== 0) {
                const f = friction * 200 * dt;
                rpm = Math.abs(rpm) < f ? 0 : rpm - Math.sign(rpm) * f;
                updateSpeedDisplay();
            }

            angle += (rpm / 60) * Math.PI * 2 * dt;

            // Static
            staticCtx.fillStyle = '#1a1a2e';
            staticCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            staticCtx.drawImage(isDrawing && activeCanvas === staticCanvas && ['line', 'circle', 'rect'].includes(currentTool) ? previewCanvas : drawCanvas, 0, 0);
            staticCtx.globalCompositeOperation = 'destination-in';
            staticCtx.beginPath();
            staticCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            staticCtx.fill();
            staticCtx.globalCompositeOperation = 'source-over';

            // Spinning
            spinningCtx.fillStyle = '#1a1a2e';
            spinningCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            spinningCtx.save();
            spinningCtx.translate(CANVAS_SIZE / 2, CANVAS_SIZE / 2);
            spinningCtx.rotate(angle);
            spinningCtx.translate(-CANVAS_SIZE / 2, -CANVAS_SIZE / 2);
            spinningCtx.drawImage(isDrawing && activeCanvas === spinningCanvas && ['line', 'circle', 'rect'].includes(currentTool) ? previewCanvas : drawCanvas, 0, 0);
            spinningCtx.restore();
            spinningCtx.globalCompositeOperation = 'destination-in';
            spinningCtx.beginPath();
            spinningCtx.arc(CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 2, 0, Math.PI * 2);
            spinningCtx.fill();
            spinningCtx.globalCompositeOperation = 'source-over';

            document.getElementById('rotation').textContent = Math.round((angle * 180 / Math.PI) % 360) + '¬∞';

            frameCount++;
            if (ts - lastFpsTime > 1000) {
                document.getElementById('fps').textContent = frameCount + ' FPS';
                frameCount = 0;
                lastFpsTime = ts;
            }

            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);
    </script>
</body>
</html>
